---
sidebar_position: 0.5
---
# FAQ?❓❓❓

## Rust 中 move、copy、clone 三者的区别是什么？分别在什么时候发生？

| 行为    | 是否自动 | 是否分配堆内存  | 适用于哪些类型                  |
| ------- | -------- | --------------- | ------------------------------- |
| `move`  | ✅        | ❌（但转移指针） | 默认所有权转移类型（如 String） |
| `copy`  | ✅        | ❌               | 实现了 `Copy` 的简单类型        |
| `clone` | ❌        | ✅               | 所有实现 `Clone` 的类型         |

**✅ 安全 + 性能 + 显式控制**

- **安全**：防止双重释放（move 会使原变量无效）
- **性能**：Copy 避免不必要的堆操作，轻量快速
- **控制力**：Clone 让开发者自己决定是否需要深拷贝，避免隐藏的性能陷阱

## Rust 中 Box、Rc、Arc 有什么区别和用途？

**相同点**

- 都是 **智能指针**，可以指向堆上分配的值（`T`）
- 都实现了 `Deref`，可以像引用一样使用（`*ptr` 或直接用 `.method()`）
- 都会在某种条件下**自动释放堆内存**（Drop）

**不同点**

| 特性     | `Box<T>`                | `Rc<T>`                    | `Arc<T>`                           |
| -------- | ----------------------- | -------------------------- | ---------------------------------- |
| 所属模块 | `std::boxed::Box`       | `std::rc::Rc`              | `std::sync::Arc`                   |
| 所有权   | 单一所有者              | 多所有者（**单线程**共享） | 多所有者（**多线程**共享）         |
| 引用计数 | ❌ 无                    | ✅ `Rc` 计数                | ✅ 原子计数（线程安全）             |
| 可变性   | 需要配合 `RefCell<T>`   | 需要配合 `RefCell<T>`      | 需要配合 `Mutex<T>` 或 `RwLock<T>` |
| 线程安全 | ❌ 不是 `Send` 或 `Sync` | ❌ 不是 `Send` 或 `Sync`    | ✅ 是 `Send + Sync`                 |
| 用途     | 最简单堆分配指针        | **单线程共享**数据结构     | **多线程共享**数据结构             |

**总结**

- `Box<T>`：**堆内存的单一所有权**
- `Rc<T>`：**单线程多所有权（共享引用）**
- `Arc<T>`：**多线程多所有权（原子引用）**

## `RefCell<T>` 是什么？和 `Rc<T>`、`Box<T>` 有什么不同？它解决了什么问题？

`RefCell<T>` 是一种 ** interior mutability ** 的数据结构，它允许在运行时改变其内容。

| 特性       | `Box<T>` | `Rc<T>`    | `RefCell<T>`                 |
| -------- | -------- | ---------- | ---------------------------- |
| 主要用途     | 堆分配      | 引用计数共享     | **内部可变性（编译期不可变 → 运行时可变）**    |
| 是否可变借用检查 | ✅ 编译期检查  | ✅ 编译期检查    | ✅ 运行时检查（通过 `Ref` / `RefMut`） |
| 多所有权     | ❌ 单一所有权  | ✅ 单线程多所有权  | ❌ 不能共享所有权，但常配合 `Rc` 使用       |
| 线程安全     | ❌ 否      | ❌ 否（不能跨线程） | ❌ 否，不能用于多线程                  |

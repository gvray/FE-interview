---
sidebar_position: 0.5
---
# FAQ?❓❓❓

## Rust 中 move、copy、clone 三者的区别是什么？分别在什么时候发生？

| 行为    | 是否自动 | 是否分配堆内存  | 适用于哪些类型                  |
| ------- | -------- | --------------- | ------------------------------- |
| `move`  | ✅        | ❌（但转移指针） | 默认所有权转移类型（如 String） |
| `copy`  | ✅        | ❌               | 实现了 `Copy` 的简单类型        |
| `clone` | ❌        | ✅               | 所有实现 `Clone` 的类型         |

**✅ 安全 + 性能 + 显式控制**

- **安全**：防止双重释放（move 会使原变量无效）
- **性能**：Copy 避免不必要的堆操作，轻量快速
- **控制力**：Clone 让开发者自己决定是否需要深拷贝，避免隐藏的性能陷阱

## Rust 中 Box、Rc、Arc 有什么区别和用途？

**相同点**

- 都是 **智能指针**，可以指向堆上分配的值（`T`）
- 都实现了 `Deref`，可以像引用一样使用（`*ptr` 或直接用 `.method()`）
- 都会在某种条件下**自动释放堆内存**（Drop）

**不同点**

| 特性     | `Box<T>`                | `Rc<T>`                    | `Arc<T>`                           |
| -------- | ----------------------- | -------------------------- | ---------------------------------- |
| 所属模块 | `std::boxed::Box`       | `std::rc::Rc`              | `std::sync::Arc`                   |
| 所有权   | 单一所有者              | 多所有者（**单线程**共享） | 多所有者（**多线程**共享）         |
| 引用计数 | ❌ 无                    | ✅ `Rc` 计数                | ✅ 原子计数（线程安全）             |
| 可变性   | 需要配合 `RefCell<T>`   | 需要配合 `RefCell<T>`      | 需要配合 `Mutex<T>` 或 `RwLock<T>` |
| 线程安全 | ❌ 不是 `Send` 或 `Sync` | ❌ 不是 `Send` 或 `Sync`    | ✅ 是 `Send + Sync`                 |
| 用途     | 最简单堆分配指针        | **单线程共享**数据结构     | **多线程共享**数据结构             |

**总结**

- `Box<T>`：**堆内存的单一所有权**
- `Rc<T>`：**单线程多所有权（共享引用）**
- `Arc<T>`：**多线程多所有权（原子引用）**

<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-frame/react/15" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Fiber 相关 | 前端面试</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://gvray.github.io/FE-interview/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://gvray.github.io/FE-interview/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://gvray.github.io/FE-interview/docs/frame/react/15"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Fiber 相关 | 前端面试"><meta data-rh="true" name="description" content="React Reconciler 为何要采用 fiber 架构？"><meta data-rh="true" property="og:description" content="React Reconciler 为何要采用 fiber 架构？"><link data-rh="true" rel="icon" href="/FE-interview/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://gvray.github.io/FE-interview/docs/frame/react/15"><link data-rh="true" rel="alternate" href="https://gvray.github.io/FE-interview/docs/frame/react/15" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://gvray.github.io/FE-interview/docs/frame/react/15" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/FE-interview/blog/rss.xml" title="前端面试 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/FE-interview/blog/atom.xml" title="前端面试 Atom Feed"><link rel="stylesheet" href="/FE-interview/assets/css/styles.f03d2e94.css">
<script src="/FE-interview/assets/js/runtime~main.768f0ad8.js" defer="defer"></script>
<script src="/FE-interview/assets/js/main.bc0b370f.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_Eduj" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><div class="announcementBar_wX4w" style="background-color:#0AC1CF;color:#000b34" role="banner"><div class="announcementBarPlaceholder_ZUmT"></div><div class="content_gHXk announcementBarContent_CTiG">⭐️ 如果您喜欢本网站，请点这里在<a target="_blank" class="cta" href="https://github.com/gvray/FE-interview"> <strong>GitHub</strong> </a>上给它一颗小星星！ ⭐️</div><button type="button" aria-label="关闭" class="clean-btn close closeButton_xMUW announcementBarClose_VbPQ"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/FE-interview/"><div class="navbar__logo"><img src="/FE-interview/img/logo.svg" alt="前端面试 Logo" class="themedComponent_R3Mz themedComponent--light_HCGW"><img src="/FE-interview/img/logo.svg" alt="前端面试 Logo" class="themedComponent_R3Mz themedComponent--dark_MXEB"></div><b class="navbar__title text--truncate">前端面试</b></a><a class="navbar__item navbar__link" href="/FE-interview/docs/basic/">基础</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/FE-interview/docs/frame/">框架</a><a class="navbar__item navbar__link" href="/FE-interview/docs/advance/">进阶</a><a class="navbar__item navbar__link" href="/FE-interview/docs/ai/">AI 开发</a><a class="navbar__item navbar__link" href="/FE-interview/docs/software/browser/">浏览器</a><a class="navbar__item navbar__link" href="/FE-interview/docs/pkg/">构建</a><a class="navbar__item navbar__link" href="/FE-interview/blog">实战案例</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/FE-interview/docs/network/">计算机网络</a><a class="navbar__item navbar__link" href="/FE-interview/docs/devops/">运维</a><a href="https://github.com/gvray/FE-interview" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_qWAS"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_rgSx colorModeToggle_mOat"><button class="clean-btn toggleButton_DUaE toggleButtonDisabled_L2KC" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_QZXE"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_mh1z"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_XIiB"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_DXLK"><div class="docsWrapper_fsaY"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_M8u6" type="button"></button><div class="docRoot_BevU"><aside class="theme-doc-sidebar-container docSidebarContainer_ITeq"><div class="sidebarViewport_i7kd"><div class="sidebar_FTAm"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_dlQ4 menuWithAnnouncementBar_rJLd"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/FE-interview/docs/frame/">前端框架</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/FE-interview/docs/category/react-1">React</a><button aria-label="折叠侧边栏分类 &#x27;React&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/">目录大纲</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/FAQ">FAQ?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/1">React生命周期</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/10">React历史版本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/11">React技巧</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/12">ErrorBoundary</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/13">React合成事件机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/14">useState 是如何实现的？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/FE-interview/docs/frame/react/15">Fiber 相关</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/2">虚拟（Virtual）dom</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/3">Diff算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/4">React状态管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/5">React性能优化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/6">setState同步异步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/7">React源码</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/8">React18新特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/FE-interview/docs/frame/react/9">React组件库</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/FE-interview/docs/category/electron-1">Electron</a><button aria-label="展开侧边栏分类 &#x27;Electron&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/FE-interview/docs/category/vue-1">Vue</a><button aria-label="展开侧边栏分类 &#x27;Vue&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/FE-interview/docs/category/vue3-1">Vue3</a><button aria-label="展开侧边栏分类 &#x27;Vue3&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/FE-interview/docs/category/nextjs-2">NEXT.js</a><button aria-label="展开侧边栏分类 &#x27;NEXT.js&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/FE-interview/docs/category/angular-1">Angular</a><button aria-label="展开侧边栏分类 &#x27;Angular&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/FE-interview/docs/category/express-1">Express</a><button aria-label="展开侧边栏分类 &#x27;Express&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_Gt9H"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_yjae"><div class="docItemContainer_hUU6"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_NLwM" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/FE-interview/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_N32E"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/FE-interview/docs/category/react-1"><span itemprop="name">React</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Fiber 相关</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_XXs2 theme-doc-toc-mobile tocMobile_WYmW"><button type="button" class="clean-btn tocCollapsibleButton_gaGM">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Fiber 相关</h1>
<h2 class="anchor anchorWithStickyNavbar_p0MW" id="react-reconciler-为何要采用-fiber-架构">React Reconciler 为何要采用 fiber 架构？<a href="#react-reconciler-为何要采用-fiber-架构" class="hash-link" aria-label="React Reconciler 为何要采用 fiber 架构？的直接链接" title="React Reconciler 为何要采用 fiber 架构？的直接链接">​</a></h2>
<p>React Reconciler 采用 Fiber 架构主要是为了提升性能和用户体验。Fiber 是 React 16 引入的一种新的协调算法，它相对于旧版的 Reconciler 具备以下优势：</p>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="1-增量渲染"><strong>1. 增量渲染</strong><a href="#1-增量渲染" class="hash-link" aria-label="1-增量渲染的直接链接" title="1-增量渲染的直接链接">​</a></h3>
<ul>
<li><strong>旧版 Reconciler</strong>：一次性计算并更新整个 UI 树，可能会导致性能瓶颈，尤其是在大型应用中。</li>
<li><strong>Fiber 架构</strong>：支持增量渲染，将渲染任务拆分为小的单元，分批执行。这样可以在长时间运行的  任务中插入中断点，使得 UI 更响应式。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="2-中断和优先级"><strong>2. 中断和优先级</strong><a href="#2-中断和优先级" class="hash-link" aria-label="2-中断和优先级的直接链接" title="2-中断和优先级的直接链接">​</a></h3>
<ul>
<li><strong>旧版 Reconciler</strong>：一旦开始更新，渲染过程无法中断，可能会阻塞用户交互。</li>
<li><strong>Fiber 架构</strong>：允许中断和恢复工作，可以根据任务的优先级来调整渲染顺序。低优先级的任务可以在高优先级任务完成后再继续执行，提高了用户交互的流畅性。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="3-任务调度"><strong>3. 任务调度</strong><a href="#3-任务调度" class="hash-link" aria-label="3-任务调度的直接链接" title="3-任务调度的直接链接">​</a></h3>
<ul>
<li><strong>旧版 Reconciler</strong>：没有任务调度机制，所有更新都按顺序执行。</li>
<li><strong>Fiber 架构</strong>：使用任务调度机制（Scheduler）来管理和调度不同优先级的更新任务，确保重要任务（如用户输入、动画）优先处理。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="4-异常处理"><strong>4. 异常处理</strong><a href="#4-异常处理" class="hash-link" aria-label="4-异常处理的直接链接" title="4-异常处理的直接链接">​</a></h3>
<ul>
<li><strong>旧版 Reconciler</strong>：异常处理能力有限，无法优雅地处理渲染过程中的错误。</li>
<li><strong>Fiber 架构</strong>：允许局部错误处理，确保在渲染过程中即使发生异常，也能保证 UI 的部分更新和恢复。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="5-渲染中断与恢复"><strong>5. 渲染中断与恢复</strong><a href="#5-渲染中断与恢复" class="hash-link" aria-label="5-渲染中断与恢复的直接链接" title="5-渲染中断与恢复的直接链接">​</a></h3>
<ul>
<li><strong>旧版 Reconciler</strong>：无法中断和恢复渲染。</li>
<li><strong>Fiber 架构</strong>：支持在渲染过程中中断并恢复，能够平滑处理长时间运行的任务。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="6-事务管理"><strong>6. 事务管理</strong><a href="#6-事务管理" class="hash-link" aria-label="6-事务管理的直接链接" title="6-事务管理的直接链接">​</a></h3>
<ul>
<li><strong>旧版 Reconciler</strong>：处理复杂的事务和操作较为困难。</li>
<li><strong>Fiber 架构</strong>：将渲染任务分解为独立的事务，每个事务可以独立地管理和控制，简化了复杂操作的管理。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_p0MW" id="fiber-架构的工作原理">fiber 架构的工作原理？<a href="#fiber-架构的工作原理" class="hash-link" aria-label="fiber 架构的工作原理？的直接链接" title="fiber 架构的工作原理？的直接链接">​</a></h2>
<p>React 中的 Fiber 架构是一种新的协调算法，旨在提高 React 的性能和用户体验。它通过引入新的数据结构和机制，使得 React 能够更高效地处理 UI 更新。以下是 Fiber 架构的工作原理：</p>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="1-fiber-数据结构"><strong>1. Fiber 数据结构</strong><a href="#1-fiber-数据结构" class="hash-link" aria-label="1-fiber-数据结构的直接链接" title="1-fiber-数据结构的直接链接">​</a></h3>
<ul>
<li><strong>Fiber 节点</strong>：Fiber 是一个表示组件的内部数据结构，每个 Fiber 节点对应一个 React 组件。它包含了组件的状态、更新信息和子组件的引用等。</li>
<li><strong>Fiber 树</strong>：Fiber 节点形成了一棵 Fiber 树，类似于旧版的虚拟 DOM 树。每个 Fiber 节点指向其父节点、子节点和兄弟节点。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="2-工作单元和增量渲染"><strong>2. 工作单元和 增量渲染</strong><a href="#2-工作单元和增量渲染" class="hash-link" aria-label="2-工作单元和增量渲染的直接链接" title="2-工作单元和增量渲染的直接链接">​</a></h3>
<ul>
<li><strong>工作单元</strong>：渲染过程被分解为多个工作单元，每个单元代表一个小的渲染任务。这样可以将渲染过程拆分成可中断的任务，以避免长时间的阻塞。</li>
<li><strong>增量渲染</strong>：Fiber 允许将渲染任务拆分为增量的操作，逐步完成整个渲染过程。每次渲染会处理 Fiber 树的一部分，允许在任务之间插入中断点，从而提高了渲染的响应性。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="3-调度优先级"><strong>3. 调度优先级</strong><a href="#3-调度优先级" class="hash-link" aria-label="3-调度优先级的直接链接" title="3-调度优先级的直接链接">​</a></h3>
<ul>
<li><strong>优先级调度</strong>：Fiber 引入了任务调度机制，允许根据任务的优先级来决定渲染的顺序。高优先级的任务（如用户输入、动画）会优先处理，而低优先级的任务（如数据加载）会在空闲时间处理。</li>
<li><strong>任务中断和恢复</strong>：Fiber 支持在渲染过程中中断并恢复任务。当重要任务需要处理时，当前的渲染任务可以被中断，待重要任务完成后再恢复继续。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="4-更新和协调"><strong>4. 更新和协调</strong><a href="#4-更新和协调" class="hash-link" aria-label="4-更新和协调的直接链接" title="4-更新和协调的直接链接">​</a></h3>
<ul>
<li><strong>更新队列</strong>：每个 Fiber 节点都有一个更新队列，用于存储与组件相关的更新信息。更新队列可以包含多个更新，React 会根据更新的优先级和顺序进行协调。</li>
<li><strong>协调过程</strong>：Fiber 通过对比新旧 Fiber 树来决定哪些部分需要更新。这一过  程称为协调（Reconciliation），它会检查节点的变更，生成更新的补丁。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="5-渲染阶段和提交阶段"><strong>5. 渲染阶段和提交阶段</strong><a href="#5-渲染阶段和提交阶段" class="hash-link" aria-label="5-渲染阶段和提交阶段的直接链接" title="5-渲染阶段和提交阶段的直接链接">​</a></h3>
<ul>
<li><strong>渲染阶段</strong>：在渲染阶段，Fiber 架构会计算出需要更新的部分，但不会立即更新 DOM。这一阶段主要用于计算新的 Fiber 树，并生成更新任务。</li>
<li><strong>提交阶段</strong>：在提交阶段，Fiber 会将渲染阶段计算出的更新应用到实际的 DOM 上。这个阶段是同步的，确保所有的更改都被正确地应用。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="6-错误处理"><strong>6. 错误处理</strong><a href="#6-错误处理" class="hash-link" aria-label="6-错误处理的直接链接" title="6-错误处理的直接链接">​</a></h3>
<ul>
<li><strong>错误边界</strong>：Fiber 提供了更好的错误处理机制，可以局部地处理渲染中的错误。即使在渲染过程中发生错误，也能保证 UI 的部分更新和恢复。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_p0MW" id="说说fiber的含义与数据结构">说说Fiber的含义与数据结构<a href="#说说fiber的含义与数据结构" class="hash-link" aria-label="说说Fiber的含义与数据结构的直接链接" title="说说Fiber的含义与数据结构的直接链接">​</a></h2>
<p>在 React 的 Fiber 架构中，“Fiber” 是一种表示组件及其状态的内部数据结构。它是对 React 组件的详细描述，旨在提高组件的渲染性能和用户体验。以下是 Fiber 的含义和数据结构的详细解释：</p>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="1-fiber-的含义"><strong>1. Fiber 的含义</strong><a href="#1-fiber-的含义" class="hash-link" aria-label="1-fiber-的含义的直接链接" title="1-fiber-的含义的直接链接">​</a></h3>
<ul>
<li><strong>Fiber 是一种内部数据结构</strong>：它用于表示每个 React 组件的状态和属性。每个 Fiber 对象包含有关组件的信息，如更新状态、子组件、位置信息等。</li>
<li><strong>Fiber 的目标</strong>：通过 Fiber 数据结构，React 可以更高效地处理 UI 更新，支持增量渲染、任务中断和优先级调度。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="2-fiber-数据结构"><strong>2. Fiber 数据结构</strong><a href="#2-fiber-数据结构" class="hash-link" aria-label="2-fiber-数据结构的直接链接" title="2-fiber-数据结构的直接链接">​</a></h3>
<p>Fiber 数据结构由多个字段组成，每个字段用于存储与组件相关的不同信息。主要字段包括：</p>
<ul>
<li><strong><code>tag</code></strong>：指示 Fiber 节点的类型，如函数组件、类组件或 DOM 元素。</li>
<li><strong><code>key</code></strong>：唯一标识 Fiber 节点的键，用于优化子节点的匹配。</li>
<li><strong><code>elementType</code></strong>：组件的类型，表示组件的类型（函数组件、类组件等）。</li>
<li><strong><code>type</code></strong>：组件的具体类型或组件实例。例如，对于 DOM 元素，它可能是 <code>&#x27;div&#x27;</code> 或 <code>&#x27;span&#x27;</code>；对于类组件，它是类构造函数。</li>
<li><strong><code>return</code></strong>：指向 Fiber 节点的父节点。形成 Fiber 树的父子关系。</li>
<li><strong><code>child</code></strong>：指向 Fiber 节点的第一个子节点。用于构建 Fiber 树的结构。</li>
<li><strong><code>sibling</code></strong>：指向 Fiber 节点的下一个兄弟节点。用于在同一层级遍历子节点。</li>
<li><strong><code>stateNode</code></strong>：保存与组件关联的实际 DOM 节点或组件实例。例如，对于类组件，它是组件的实例；对于 DOM 元素，它是实际的 DOM 节点。</li>
<li><strong><code>alternate</code></strong>：指向 Fiber 节点的旧版本（即上一次渲染时的 Fiber 节点）。用于比较新旧 Fiber 树，进行更新和协调。</li>
<li><strong><code>updateQueue</code></strong>：保存组件的更新队列，包含需要应用的更新信息。每个更新记录可能包含一个新的状态或属性。</li>
<li><strong><code>effectTag</code></strong>：用于标记 Fiber 节点的更新效果（如插入、更新或删除）。在提交阶段，React 会根据这些标记进行实际的 DOM 更新。</li>
<li><strong><code>pendingProps</code></strong> 和 <strong><code>memoizedProps</code></strong>：分别表示待处理的属性和已记忆的属性。<code>pendingProps</code> 是新传入的属性，而 <code>memoizedProps</code> 是上一次渲染时的属性。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="3-fiber-树"><strong>3. Fiber 树</strong><a href="#3-fiber-树" class="hash-link" aria-label="3-fiber-树的直接链接" title="3-fiber-树的直接链接">​</a></h3>
<ul>
<li><strong>Fiber 树结构</strong>：Fiber 树类似于虚拟 DOM 树，表示组件的层级结构。每个 Fiber 节点代表一个组件或 DOM 元素。Fiber 树通过 <code>return</code>、<code>child</code> 和 <code>sibling</code> 字段构建成树形结构。</li>
<li><strong>更新和协调</strong>：在 Fiber 架构中，React 使用 Fiber 数据结构来处理组件更新和协调（Reconciliation）。通过比较新旧 Fiber 树，React 可以计算出需要更新的部分并生成补丁。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="4-fiber-的优势"><strong>4. Fiber 的优势</strong><a href="#4-fiber-的优势" class="hash-link" aria-label="4-fiber-的优势的直接链接" title="4-fiber-的优势的直接链接">​</a></h3>
<ul>
<li><strong>增量渲染</strong>：Fiber 支持将渲染任务拆分为多个增量的工作单元，允许中断和恢复渲染，避免长时间的阻塞。</li>
<li><strong>  优先级调度</strong>：Fiber 引入了任务优先级调度，允许高优先级的任务（如用户输入）优先处理，提高响应性。</li>
<li><strong>错误边界</strong>：Fiber 提供了更好的错误处理机制，可以局部地处理渲染中的错误，保证应用的稳定性。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_p0MW" id="说说-react-render-阶段的执行过程">说说 React render 阶段的执行过程<a href="#说说-react-render-阶段的执行过程" class="hash-link" aria-label="说说 React render 阶段的执行过程的直接链接" title="说说 React render 阶段的执行过程的直接链接">​</a></h2>
<p>在 React 的 Fiber 架构中，<code>render</code> 阶段是处理组件更新和生成虚拟 DOM 的关键阶段。</p>
<p>以下是 React 在 <code>render</code> 阶段的执行过程的详细步骤：</p>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="1-触发渲染">1. <strong>触发渲染</strong><a href="#1-触发渲染" class="hash-link" aria-label="1-触发渲染的直接链接" title="1-触发渲染的直接链接">​</a></h3>
<ul>
<li><strong>更新请求</strong>：组件的状态或属性发生变化时，会触发一次渲染。更新可以由用户交互、网络请求响应或内部状态变化等引起。</li>
<li><strong>调度更新</strong>：React 会将渲染任务调度到 Fiber 树的更新队列中。调度过程使用 React 的调度器来确定任务的优先级。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="2-开始-fiber-树的协调">2. <strong>开始 Fiber 树的协调</strong><a href="#2-开始-fiber-树的协调" class="hash-link" aria-label="2-开始-fiber-树的协调的直接链接" title="2-开始-fiber-树的协调的直接链接">​</a></h3>
<ul>
<li><strong>创建 Fiber 节点</strong>：在 <code>render</code> 阶段，React 会为每个组件创建或更新 Fiber 节点。Fiber 节点用于表示组件及其状态，包括当前的属性、子节点和更新队列等。</li>
<li><strong>  更新 Fiber 树</strong>：React 会将新的 Fiber 节点与旧的 Fiber 节点进行比较。这一步称为协调（Reconciliation）。React 会遍历 Fiber 树，对比新旧 Fiber 节点，计算出最小的更新集合。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="3-执行-render-方法">3. <strong>执行 <code>render</code> 方法</strong><a href="#3-执行-render-方法" class="hash-link" aria-label="3-执行-render-方法的直接链接" title="3-执行-render-方法的直接链接">​</a></h3>
<ul>
<li><strong>执行组件的 <code>render</code> 方法</strong>：对于每个 Fiber 节点，React 会执行组件的 <code>render</code> 方法。<code>render</code> 方法会返回一个虚拟 DOM 树，这个虚拟 DOM 树会被包装成新的 Fiber 节点。</li>
<li><strong>构建新的 Fiber 树</strong>：<code>render</code> 方法返回的虚拟 DOM 会被转换成新的 Fiber 节点，并替代旧的 Fiber 节点。新的 Fiber 节点将会作为子节点插入到父节点的子节点链中。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="4-更新-fiber-节点">4. <strong>更新 Fiber 节点</strong><a href="#4-更新-fiber-节点" class="hash-link" aria-label="4-更新-fiber-节点的直接链接" title="4-更新-fiber-节点的直接链接">​</a></h3>
<ul>
<li><strong>处理更新</strong>：在 Fiber 节点中，React 会处理更新队列，应用新的状态或属性。<code>pendingProps</code> 和 <code>memoizedProps</code> 分别表示待处理的属性和已记忆的属性。</li>
<li><strong>标记更新类型</strong>：React 会在 Fiber 节点中设置 <code>effectTag</code>，标记当前 Fiber 节点的更新类型，如插入、更新或删除。这些标记将用于提交阶段的实际 DOM 更新。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="5-构建-fiber-树的副作用">5. <strong>构建 Fiber 树的副作用</strong><a href="#5-构建-fiber-树的副作用" class="hash-link" aria-label="5-构建-fiber-树的副作用的 直接链接" title="5-构建-fiber-树的副作用的直接链接">​</a></h3>
<ul>
<li><strong>保存副作用</strong>：在 <code>render</code> 阶段，React 会收集和保存副作用（side effects），例如需要在组件挂载或更新时执行的副作用操作（如数据获取、事件监听等）。这些副作用将在 <code>commit</code> 阶段应用到实际 DOM 上。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="6-完成-render-阶段">6. <strong>完成 <code>render</code> 阶段</strong><a href="#6-完成-render-阶段" class="hash-link" aria-label="6-完成-render-阶段的直接链接" title="6-完成-render-阶段的直接链接">​</a></h3>
<ul>
<li><strong>生成新的 Fiber 树</strong>：完成 <code>render</code> 阶段后，React 会生成一棵新的 Fiber 树，这棵树包含了所有更新后的 Fiber 节点。</li>
<li><strong>准备提交</strong>：新的 Fiber 树会被提交到 <code>commit</code> 阶段进行实际的 DOM 更新。提交过程包括应用副作用和实际的 DOM 操作。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_p0MW" id="react-commit-阶段的执行过程">React commit 阶段的执行过程<a href="#react-commit-阶段的执行过程" class="hash-link" aria-label="React commit 阶段的执行过程的直接链接" title="React commit 阶段的执行过程的直接链接">​</a></h2>
<p>在 React 的 Fiber 架构中，<code>commit</code> 阶段是将更新应用到实际 DOM 的关键步骤。这个阶段处理在 <code>render</code> 阶段中计算出的所有副作用，并实际更新页面内容。以下是 <code>commit</code> 阶段的详细执行过程：</p>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="1-提交-fiber-树">1. <strong>提交 Fiber 树</strong><a href="#1-提交-fiber-树" class="hash-link" aria-label="1-提交-fiber-树的直接链接" title="1-提交-fiber-树的直接链接">​</a></h3>
<ul>
<li><strong>获取 Fiber 树</strong>：<code>commit</code> 阶段开始时，React 会获取从 <code>render</code> 阶段生成的 Fiber 树。这棵树包含所有需要更新的 Fiber 节点及其副作用标记。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="2-遍历-fiber-树">2. <strong>遍历 Fiber 树</strong><a href="#2-遍历-fiber-树" class="hash-link" aria-label="2-遍历-fiber-树的直接链接" title="2-遍历-fiber-树的直接链接">​</a></h3>
<ul>
<li><strong>递归遍历</strong>：React 会递归遍历 Fiber 树，从根节点开始，逐层处理每个 Fiber 节点。每个节点会根据其 <code>effectTag</code> 属性执行相应的操作。</li>
<li><strong>处理副作用</strong>：副作用包括插入、更新和删除 DOM 元素、执行生命周期方法、调用 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的回调函数等。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="3-应用副作用">3. <strong>应用副作用</strong><a href="#3-应用副作用" class="hash-link" aria-label="3-应用副作用的直接链接" title="3-应用副作用的直接链接">​</a></h3>
<ul>
<li><strong>插入节点</strong>：对于标记为插入的 Fiber 节点，React 会在实际 DOM 中插入对应的节点。这包括创建新的 DOM 元素、设置属性和插入到正确的位置。</li>
<li><strong>更新节点</strong>：对于标记为更新的 Fiber 节点，React 会更新现有的 DOM 元素。这包括更新元素的属性、文本内容和样式等。</li>
<li><strong>删除节点</strong>：对于标记为删除的 Fiber 节点，React 会从实际 DOM 中移除对应的节点。这包括删除元素、清理事件监听器等。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="4-处理生命周期方法和副作用">4. <strong>处理生命周期方法和副作用</strong><a href="#4-处理生命周期方法和副作用" class="hash-link" aria-label="4-处理生命周期方法和副作用的直接链接" title="4-处理生命周期方法和副作用的直接链接">​</a></h3>
<ul>
<li><strong>调用生命周期方法</strong>：在 <code>commit</code> 阶段，React 会调用组件的生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</li>
<li><strong>执行 <code>useEffect</code> 和 <code>useLayoutEffect</code></strong>：React 会执行 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的回调函数。这些回调函数在组件挂载和更新后执行，用于处理副作用操作（如数据获取、事件绑定等）。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="5-更新-fiber-树">5. <strong>更新 Fiber 树</strong><a href="#5-更新-fiber-树" class="hash-link" aria-label="5-更新-fiber-树的直接链接" title="5-更新-fiber-树的直接链接">​</a></h3>
<ul>
<li><strong>更新 Fiber 节点</strong>：在 <code>commit</code> 阶段完成后，React 会更新 Fiber 节点的状态和属性，将 <code>current</code> 树指向新的 Fiber 树。</li>
<li><strong>清理工作</strong>：完成副作用处理后，React 会清理 Fiber 节点上的副作用标记和临时状态，为下一次渲染做好准备。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="6-浏览器布局和绘制">6. <strong>浏览器布局和绘制</strong><a href="#6-浏览器布局和绘制" class="hash-link" aria-label="6-浏览器布局和绘制的直接链接" title="6-浏览器布局和绘制的直接链接">​</a></h3>
<ul>
<li><strong>布局计算</strong>：在实际 DOM 更新后，浏览器会进行布局计算，确定元素的最终位置和尺寸。</li>
<li><strong>绘制</strong>：浏览器会根据布局计算结果绘制页面内容。这个过程包括将元素绘制到屏幕上，并处理样式、颜色和图像等。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_p0MW" id="react-中fiber-是如何实现时间切片的">React 中，fiber 是如何实现时间切片的？<a href="#react-中fiber-是如何实现时间切片的" class="hash-link" aria-label="React 中，fiber 是如何实现时间切片的？的直接链接" title="React 中，fiber 是如何实现时间切片的？的直接链接">​</a></h2>
<p>Fiber 的时间切片（Time Slicing）是一种优化 React 渲染性能的技术，它允许将长时间运行的任务分解成多个小任务，以便在主线程上交替执行其他任务，从而提高用户界面的响应性。以下是时间切片在 Fiber 架构中实现的主要原理和步骤：</p>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="1-任务拆分和优先级"><strong>1. 任务拆分和优先级</strong><a href="#1-任务拆分和优先级" class="hash-link" aria-label="1-任务拆分和优先级的直接链接" title="1-任务拆分和优先级的直接链接">​</a></h3>
<ul>
<li><strong>任务拆分</strong>：Fiber 架构允许将长时间运行的任务（如组件更新）拆分成多个小的 Fiber 节点处理单元。这些小任务可以在浏览器的空闲时间中逐步完成，而不是一次性处理所有任务。</li>
<li><strong>优先级调度</strong>：React 为不同的更新任务分配不同的优先级。例如，用户输入相关的更新（如点击和输入事件）通常会被赋予较高的优先级，而低优先级的更新（如数据预取）则可能在用户操作之后执行。优先级调度可以确保重要的任务优先处理。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="2-任务调度"><strong>2. 任务调度</strong><a href="#2-任务调度" class="hash-link" aria-label="2-任务调度的直接链接" title="2-任务调度的直接链接">​</a></h3>
<ul>
<li><strong>调度器（Scheduler）</strong>：React 使用调度器来控制任务的执行。调度器决定何时执行 Fiber 节点的更新工作，以及在主线程上分配的时间片。调度器会根据任务的优先级和浏览器的空闲时间来安排任务执行。</li>
<li><strong>时间片切换</strong>：时间切片的核心思想是将长时间运行的任务分割成多个时间片（时间段），并在每个时间片内处理 一部分任务。在每个时间片结束时，React 会检查是否有更高优先级的任务需要处理，或者是否需要将当前任务暂停，等待下一次时间片继续处理。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="3-fiber-节点的处理"><strong>3. Fiber 节点的处理</strong><a href="#3-fiber-节点的处理" class="hash-link" aria-label="3-fiber-节点的处理的直接链接" title="3-fiber-节点的处理的直接链接">​</a></h3>
<ul>
<li><strong>工作单元</strong>：每个 Fiber 节点代表一个工作单元，处理 Fiber 节点的任务被称为“工作单元”。在时间切片过程中，React 会逐步处理这些工作单元，以便将渲染任务拆分成较小的部分。</li>
<li><strong>中断与恢复</strong>：如果在处理 Fiber 节点的过程中，浏览器遇到用户交互（如点击或滚动），React 可以中断当前任务，并优先处理这些用户交互相关的高优先级任务。一旦用户交互处理完成，React 会恢复中断的任务，继续处理剩余的 Fiber 节点。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="4-流程实现"><strong>4. 流程实现</strong><a href="#4-流程实现" class="hash-link" aria-label="4-流程实现的直接链接" title="4-流程实现的直接链接">​</a></h3>
<ol>
<li><strong>任务开始</strong>：当 React 开始执行更新任务时，它会将任务拆分成多个 Fiber 节点的处理单元，并根据优先级安排这些任务。</li>
<li><strong>调度执行</strong>：调度器会分配时间片来处理这些 Fiber 节点。每个时间片内，React 会处理一定数量的 Fiber 节点，更新虚拟 DOM 和实际 DOM。</li>
<li><strong>检查任务状态</strong>：在每个时间片结束时，React 会检查是否有高优先级任务需要处理，或者是否需要暂停当前任务。调度器决定是否继续执行当前任务或切换到其他任务。</li>
<li><strong>恢复执行</strong>：如果任务被中断，React 会在下  一次时间片中恢复执行，继续处理未完成的 Fiber 节点。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="5-用户交互"><strong>5. 用户交互</strong><a href="#5-用户交互" class="hash-link" aria-label="5-用户交互的直接链接" title="5-用户交互的直接链接">​</a></h3>
<ul>
<li><strong>响应用户操作</strong>：时间切片技术确保用户操作（如输入、点击）能够及时响应。React 在处理高优先级任务时，能够快速响应用户交互，提高页面的交互性能。</li>
<li><strong>优化渲染</strong>：通过将长时间运行的任务分解成多个时间片，React 能够避免阻塞主线程，提高页面的整体性能和响应性。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_p0MW" id="总结"><strong>总结</strong><a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h3>
<p>Fiber 的时间切片实现使得 React 能够高效地处理长时间运行的渲染任务，通过将任务拆分成多个小任务，并在主线程上分配时间片来逐步完成这些任务。这种方法可以显著提高用户界面的响应性和性能，确保高优先级任务能够及时处理，并优化页面渲染体验。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/gvray/FE-interview/tree/main/docs/frame/react/15.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_BeV9" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_VoS0"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/FE-interview/docs/frame/react/14"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">useState 是如何实现的？</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/FE-interview/docs/frame/react/2"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">虚拟（Virtual）dom</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_aKmz thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#react-reconciler-为何要采用-fiber-架构" class="table-of-contents__link toc-highlight">React Reconciler 为何要采用 fiber 架构？</a><ul><li><a href="#1-增量渲染" class="table-of-contents__link toc-highlight"><strong>1. 增量渲染</strong></a></li><li><a href="#2-中断和优先级" class="table-of-contents__link toc-highlight"><strong>2. 中断和优先级</strong></a></li><li><a href="#3-任务调度" class="table-of-contents__link toc-highlight"><strong>3. 任务调度</strong></a></li><li><a href="#4-异常处理" class="table-of-contents__link toc-highlight"><strong>4. 异常处理</strong></a></li><li><a href="#5-渲染中断与恢复" class="table-of-contents__link toc-highlight"><strong>5. 渲染中断与恢复</strong></a></li><li><a href="#6-事务管理" class="table-of-contents__link toc-highlight"><strong>6. 事务管理</strong></a></li></ul></li><li><a href="#fiber-架构的工作原理" class="table-of-contents__link toc-highlight">fiber 架构的工作原理？</a><ul><li><a href="#1-fiber-数据结构" class="table-of-contents__link toc-highlight"><strong>1. Fiber 数据结构</strong></a></li><li><a href="#2-工作单元和增量渲染" class="table-of-contents__link toc-highlight"><strong>2. 工作单元和增量渲染</strong></a></li><li><a href="#3-调度优先级" class="table-of-contents__link toc-highlight"><strong>3. 调度优先级</strong></a></li><li><a href="#4-更新和协调" class="table-of-contents__link toc-highlight"><strong>4. 更新和协调</strong></a></li><li><a href="#5-渲染阶段和提交阶段" class="table-of-contents__link toc-highlight"><strong>5. 渲染阶段和提交阶段</strong></a></li><li><a href="#6-错误处理" class="table-of-contents__link toc-highlight"><strong>6. 错误处理</strong></a></li></ul></li><li><a href="#说说fiber的含义与数据结构" class="table-of-contents__link toc-highlight">说说Fiber的含义与数据结构</a><ul><li><a href="#1-fiber-的含义" class="table-of-contents__link toc-highlight"><strong>1. Fiber 的含义</strong></a></li><li><a href="#2-fiber-数据结构" class="table-of-contents__link toc-highlight"><strong>2. Fiber 数据结构</strong></a></li><li><a href="#3-fiber-树" class="table-of-contents__link toc-highlight"><strong>3. Fiber 树</strong></a></li><li><a href="#4-fiber-的优势" class="table-of-contents__link toc-highlight"><strong>4. Fiber 的优势</strong></a></li></ul></li><li><a href="#说说-react-render-阶段的执行过程" class="table-of-contents__link toc-highlight">说说 React render 阶段的执行过程</a><ul><li><a href="#1-触发渲染" class="table-of-contents__link toc-highlight">1. <strong>触发渲染</strong></a></li><li><a href="#2-开始-fiber-树的协调" class="table-of-contents__link toc-highlight">2. <strong>开始 Fiber 树的协调</strong></a></li><li><a href="#3-执行-render-方法" class="table-of-contents__link toc-highlight">3. <strong>执行 <code>render</code> 方法</strong></a></li><li><a href="#4-更新-fiber-节点" class="table-of-contents__link toc-highlight">4. <strong>更新 Fiber 节点</strong></a></li><li><a href="#5-构建-fiber-树的副作用" class="table-of-contents__link toc-highlight">5. <strong>构建 Fiber 树的副作用</strong></a></li><li><a href="#6-完成-render-阶段" class="table-of-contents__link toc-highlight">6. <strong>完成 <code>render</code> 阶段</strong></a></li></ul></li><li><a href="#react-commit-阶段的执行过程" class="table-of-contents__link toc-highlight">React commit 阶段的执行过程</a><ul><li><a href="#1-提交-fiber-树" class="table-of-contents__link toc-highlight">1. <strong>提交 Fiber 树</strong></a></li><li><a href="#2-遍历-fiber-树" class="table-of-contents__link toc-highlight">2. <strong>遍历 Fiber 树</strong></a></li><li><a href="#3-应用副作用" class="table-of-contents__link toc-highlight">3. <strong>应用副作用</strong></a></li><li><a href="#4-处理生命周期方法和副作用" class="table-of-contents__link toc-highlight">4. <strong>处理生命周期方法和副作用</strong></a></li><li><a href="#5-更新-fiber-树" class="table-of-contents__link toc-highlight">5. <strong>更新 Fiber 树</strong></a></li><li><a href="#6-浏览器布局和绘制" class="table-of-contents__link toc-highlight">6. <strong>浏览器布局和绘制</strong></a></li></ul></li><li><a href="#react-中fiber-是如何实现时间切片的" class="table-of-contents__link toc-highlight">React 中，fiber 是如何实现时间切片的？</a><ul><li><a href="#1-任务拆分和优先级" class="table-of-contents__link toc-highlight"><strong>1. 任务拆分和优先级</strong></a></li><li><a href="#2-任务调度" class="table-of-contents__link toc-highlight"><strong>2. 任务调度</strong></a></li><li><a href="#3-fiber-节点的处理" class="table-of-contents__link toc-highlight"><strong>3. Fiber 节点的处理</strong></a></li><li><a href="#4-流程实现" class="table-of-contents__link toc-highlight"><strong>4. 流程实现</strong></a></li><li><a href="#5-用户交互" class="table-of-contents__link toc-highlight"><strong>5. 用户交互</strong></a></li><li><a href="#总结" class="table-of-contents__link toc-highlight"><strong>总结</strong></a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">面试宝典</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs">八股文(ALL.)</a></li><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs/category/设计模式">设计模式</a></li><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs/category/算法">算法</a></li><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs/category/软件服务">软件服务</a></li><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs/category/服务端开发">服务端开发</a></li><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs/category/手写练习场">手写练习场</a></li></ul></div><div class="col footer__col"><div class="footer__title">多端开发</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">移动端</a></li><li class="footer__item"><a href="#" class="footer__link-item">小程序</a></li><li class="footer__item"><a class="footer__link-item" href="/FE-interview/docs/category/移动端开发">桌面软件</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="#" class="footer__link-item">Stack Overflow</a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/FE-interview/blog">博客</a></li><li class="footer__item"><a href="https://github.com/gvray/FE-interview" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_qWAS"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 FE-interview. Built with GavinRay's Docusaurus.</div></div></div></footer></div>
</body>
</html>